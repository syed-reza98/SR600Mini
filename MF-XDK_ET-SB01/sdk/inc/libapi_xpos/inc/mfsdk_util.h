/**
 * @file mfsdk_util.h
 * @author Bone
 * @brief 
 * @date 2023-11-24
 * @copyright Fujian MoreFun Electronic Technology Co., Ltd.
 */

#ifndef __MFSDK_UTIL_H__
#define __MFSDK_UTIL_H__
#include "mfsdk_define.h"

typedef enum
{
	MFSDK_UTIL_RET_FAILED = -3, //failed 
	MFSDK_UTIL_RET_BOUNDS = -2, //Array out-of-bounds 
	MFSDK_UTIL_RET_PARM_ERROR = -1, //check param
	MFSDK_UTIL_RET_OK = 0,
}MfSdkUtilRet_E;

//QR code parameters
typedef struct
{
	s32 nVersion;		///< version number:1~40
	s32 nLevel;			///< Error correction level: 0-low, 1-in, 2-high, 3-maximum,
	s32 moduleWidth;	///< Module width (unit: pixel)
} MfSdkUtilQrInfo_T;


typedef enum {
    MFSDK_UTIL_MD_SHA1,      /**< The SHA-1 message digest. */
    MFSDK_UTIL_MD_SHA256,    /**< The SHA-256 message digest. */
    MFSDK_UTIL_MD_SHA512,    /**< The SHA-512 message digest. */
} MfSdkUtilMDType_E;


/**
 * @brief Get util module version
 *
 * @param[out] pszVer Module version 
 * @return	0, Success 
 * @return	Other, Failure
 */
LIB_EXPORT s32 MfSdkUtilGetModuleVer(s8 *pszVer);

/**
 * @brief ASCII code to BCD code
 * 
 * @param[in] AscBuf ASCII code data to be converted
 * @param[out] BcdBuf Conversion output BCD code data
 * @param[in] AscLen Incoming ASCII code data length
 * @return	0, Success 
 * @return	Other, Failure
 * @details The left is BCD code, and the digit is insufficient to supplement'F'
 */
LIB_EXPORT s32 MfSdkUtilAsc2Bcd(s8 *AscBuf, s8 *BcdBuf, s32 AscLen);

/**
 * @brief BCD code to ASCII code
 *
 * @param[in] BcdBuf BCD code data to be converted
 * @param[out] AscBuf Conversion output ASCII code data
 * @param[in] AscLen The length of ASCII code data, that is the double length of BCD code data
 * @return	0, Success 
 * @return	Other, Failure
 */
LIB_EXPORT s32 MfSdkUtilBcd2Asc(s8 *BcdBuf, s8 *AscBuf, s32 AscLen);

/**
 * @brief
 * 
 * @param[in] u8* pszBcdBuf
 * @param[in] s32 AscLen
 * @param[in] s8 cAlignment 1 - left align , 0 - right align
 * @param[out] u8* pszAsciiBuf
 * @return	0, Success 
 * @return	Other, Failure
 */
LIB_EXPORT s32 MfSdkUtilHex2Asc(u8* pszBcdBuf, s32 AscLen, s8 cAlignment, u8* pszAsciiBuf);

/**
 * @brief Int data transfer to BCD code
 *
 * @param[in] IntData Int data to be converted
 * @param[out] BcdBuf BCD data after conversion
 * @param[in] BcdLen Length of BCD code data after conversion
 * @return	0, Success 
 * @return	Other, Failure
 * @details The BCD code is on the right, and the number is not enough to add 0 to the left
 */
LIB_EXPORT s32 MfSdkUtilInt2Bcd(u32 IntData, s8 *BcdBuf, s32 BcdLen);

/**
 * @brief BCD code to int type
 *
 * @param[in] BcdBuf BCD data to be converted
 * @param[out] IntData Int data after conversion
 * @param[in] BcdLen BCD code data length
 * @return	0, Success 
 * @return	Other, Failure
 */
LIB_EXPORT s32 MfSdkUtilBcd2Int(s8 *BcdBuf, u32 *IntData, s32 BcdLen);

/**
 * @brief Calculates LRC and generates LRC parity bits (bitwise exclusive or)
 *
 * @param[in] Data Data to be calculated for LRC check bits
 * @param[in] DataLen Data length
 * @return  The LRC check value generated by calculation
 */
LIB_EXPORT u8 MfSdkUtilGenLrc(s8 *Data, s32 DataLen);

/**
 * @brief DES encryption and decryption to DES data encryption and decryption, or 3DES encryption and decryption
 *
 * @param[in]  bDesType DES encryption and decryption algorithm:
				0 denotes DES encryption, 
				1 denotes DES decryption, 
				2 denotes 3DES encryption(16 bytes key), 
				3 denotes 3DES decryption(16 bytes key),
				4 denotes 3DES encryption(24 bytes key), 
				5 denotes 3DES decryption(24 bytes key).
 * @param[in] bDesMode 0 ECB 1 CBC
 * @param[in] Key Used for encryption and decryption of transmission keys, must be 8 times
 * @param[in] InData Input data to be encrypted or decrypted must be 8 times bytes
 * @param[in] DataLen The length of input data
 * @param[out] OutData The key after encryption and decryption must be 8 bytes
 * @return	0, Success 
 * @return	Other, Failure
 */
LIB_EXPORT s32 MfSdkUtilDes(u8 bDesType, u8 bDesMode, s8 *Key, s8 *InData, s32 DataLen, s8 *OutData);

/**
 * @brief Buzzing success indicates buzzing when successful, non blocking
 *
 * @param[in] num Buzz times
 */
LIB_EXPORT void MfSdkUtilBeep(s32 num);

/**
 * @brief Set the buzzer ringing time
 * 
 * @param[in] nMillisecond ringing time(Unit millisecond)
 */
LIB_EXPORT void MfSdkUtilBuzzerSound(s32 nMillisecond);

/**
 * @brief Generating random numbers
 *
 * @param[in] len random number len
 * @param[out] pBuf random number
 * @return	0, Success
 * @return	Other, Failure
 * @details Priority of true random numbers
 */
LIB_EXPORT s32 MfSdkUtilGetRand(s32 len, u8* pBuf);

/**
 * @brief Util_SHA1
 *
 * @param[in] psSrc Source buffer
 * @param[in] nSrcLen Source length
 * @param[out] psDst Result of SHA1
 * @return	0, Success 
 * @return	Other, Failure
 */
LIB_EXPORT s32 MfSdkUtilSHA1(const u8* psSrc, u32 nSrcLen, u8* psDst);

/**
 * @brief QR code generation
 *
 * @param[in] chData QR code data
 * @param[in] iLen Data length
 * @param[in] qrparam QR code parameters
 * @param[out] bitmap Generated two-dimensional code dot matrix data
 * @return	>0, Successfully generated QR code width
 * @return	Other, Failure
 */
LIB_EXPORT s32 MfSdkUtilGeneCodePic(s8 * chData, s32 iLen, MfSdkUtilQrInfo_T *qrparam , s8 * bitmap);

/**
 * @brief LED light control
 *
 * @param[in] num LED light number(0 red, 1 blue, 2 yellow, 3 green)
 * @param[in] type LED light switch(0 close, 1 open)
 */
LIB_EXPORT void MfSdkUtilLed(s32 num, s32 type);

/**
 * @brief String to long long
 * 
 * @param[in] const s8 *amt
 * @return	value
 */
LIB_EXPORT long long MfSdkUtilStr2Longlong(const s8 *amt);

/**
 * @brief File MD5 value calculation
 * 
 * @param[in] const s8* pszFilePath
 * @param[out] u8* pOutMD5
 * @return MFSDK_FALSE file not found
 * @return MFSDK_TRUE success
 */
LIB_EXPORT s32 MfSdkUtilMd5File(const s8* pszFilePath, u8* pOutMD5);

/**
 * @brief Utf-8 string to ASCII string
 * 
 * @param[in] char *utfstr  utf-8 string
 * @param[in] s32 utfchars  utf-8 string length
 * @param[out] u8*astr		out ascii string
 * @param[in] s32 buffsize  astr buffer size
 * @return > 0 ascii length
 * @return other fail
 */
LIB_EXPORT s32 MfSdkUtilUtf8str2Astr(char *utfstr, s32 utfchars, u8*astr,s32 buffsize);

/**
 * @brief Unicode data transfer to utf-8 code
 *
 * @param[in] codepoint Unicode data to be converted
 * @param[out] outstr utf-8 data after conversion
 * @return	The length of outstr
 */
LIB_EXPORT s32 MfSdkUtilUnicodeToUtf8(u16 codepoint, s8 *outstr);

/**
 * @brief utf-8 code data transfer to Unicode
 *
 * @param[in] instr utf-8 data to be converted
 * @param[out] outstr Unicode data after conversion
 * @return	The length of outstr
 */
LIB_EXPORT s32 MfSdkUtilUtf8ToUnicode(u8 *instr, u8 *outstr);

/**
 * @brief
 * 
 * @param[in] u8*tagName, tag name eg. "\x9F\x02"
 * @param[in] u8 *pInBuf, tlv bytes stream
 * @param[in] s32 inBufLength, tlv bytes stream length
 * @param[out] u8 *pValue ,tagName value
 * @param[in] s32 valueLength, pValue buffer size
 * @return >= 0  pValue length
 * @return MFSDK_UTIL_RET_PARM_ERROR
 * @return  MFSDK_UTIL_RET_FAILED
 */
LIB_EXPORT s32 MfSdkUtilTlvGetDataByTag(u8*tagName,u8 *pInBuf,s32 inBufLength,u8 *pValue, s32 valueLength);

/**
 * @brief Set the buzzer ringing time and Hz
 *
 * @param[in] ms ms
 * @param[in] hz beep hz
 * @details  750Hz ringing 500ms,MfSdkUtilCtrlBeep(500,750)
 */
LIB_EXPORT void MfSdkUtilCtrlBeep(int ms, int hz);

/**
 * @brief           Write a private key to a PKCS#1 or SEC1 PEM string
 *
 * @param ctx       private to write away mbedtls_pk_context*
 * @param buf       buffer to write to
 * @param size      size of the buffer
 *
 * @return          0 if successful, or a specific error code
 */
LIB_EXPORT s32 MfSdkUtilPkWriteKeyPem( void *ctx, u8*buf, u32 size);

/**
 * @brief           Write a public key to a PEM string
 *
 * @param ctx       public key to write away mbedtls_pk_context*
 * @param buf       buffer to write to
 * @param size      size of the buffer
 *
 * @return          0 if successful, or a specific error code
 */
LIB_EXPORT s32 MfSdkUtilPkWritePubkeyPem(void *ctx, u8 *buf, u32 size );

/**
 * @brief Generate RSA public and private keys. 
 *  The exponent is fixed at  65537
 * @param[in] s32 keyBits  RSA key bits
 * @param[out] u8 *privPem  private key  format is pem
 * @param[in] s32 privPemLength   privPem buffer size
 * @param[out] u8 *pubPem  public key format is pem
 * @param[in] s32 pubPemLength  pubPem buffer size
 * @param[in] s32 timeoutMs
 * @return 0 - success , other - fail
 */
LIB_EXPORT s32 MfSdkUtilGenRsa(s32 keyBits,u8 *privPem, s32 privPemLength,u8 *pubPem, s32 pubPemLength,s32 timeoutMs);

/**
 * @brief Generate RSA key
 * 
 * @param[in] u8 index
 * @param[in] s32 keyBits  1024 - 4096 bits
 * @param[in] s32 timeoutMs
 * @return 0 - success, other - failed
 */
LIB_EXPORT s32 MfSdkUtilGenRsaKey(u8 index,s32 keyBits,s32 timeoutMs);

/**
 * @brief Generate RSA signature
 * 
 * @param[in] u8 index
 * @param[in] MfSdkUtilMDType_E mdAlg
 * @param[in] u8* hash
 * @param[in] s32 hashLength
 * @param[out] u8* signData
 * @param[out] s32 signDataLength
 * @return > 0 success , signData length
 * @return other failed
 */
LIB_EXPORT s32 MfSdkUtilRsaSign(u8 index ,MfSdkUtilMDType_E mdAlg, u8* hash , s32 hashLength,u8* signData,s32 signDataLength);

/**
 * @brief Get RSA public key
 * 
 * @param[in] u8 index
 * @param[out] u8 *pubPem
 * @param[in] s32 pubPemLength
 * @return 0 - success ,other - failed
 */
LIB_EXPORT s32 MfSdkUtilRsaGetPublicKey(u8 index , u8 *pubPem, s32 pubPemLength);


/**
 * @brief del index RSA key
 * 
 * @param[in] u8 index
 * @return MFSDK_UTIL_RET_FAILED not found index RSA key
 * @return MFSDK_UTIL_RET_OK del successfully
 */
LIB_EXPORT s32 MfSdkUtilGenRsaDelKey(u8 index);

/**
 * @brief  del all RSA key
 * 
 * @return MFSDK_UTIL_RET_OK
 */
LIB_EXPORT s32 MfSdkUtilGenRsaDelAllKey(void);

/**
 * @brief For mbedtls rand
 * 
 * @param[in] void* para
 * @param[in] u8* pbuf
 * @param[in] u32 len
 * @return 0
 */
LIB_EXPORT s32 MfSdkUtilRsaRand(void* para, u8* pbuf, u32 len);

/**
 * @brief
 *  Compresses the source buffer into the destination buffer. The level
 *  parameter has the same meaning as in deflateInit.  sourceLen is the byte
 *  length of the source buffer. Upon entry, destLen is the total size of the
 *  destination buffer, which must be at least 0.1% larger than sourceLen plus
 *  12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
 * @param[out] u8*dest
 * @param[in/out] u32 *destLen
 * @param[in] const u8* source
 * @param[in] u32 sourceLen
 * @return MFSDK_UTIL_RET_OK / MFSDK_UTIL_RET_FAILED
 */
 
LIB_EXPORT s32 MfSdkUtilCompress (u8*dest, u32 *destLen, const u8* source, u32 sourceLen);

/**
 * @brief get compress bound
 * @param[in] u32 sourceLen
 * @return compress bound value
 */
LIB_EXPORT u32 MfSdkUtilCompressBound (u32 sourceLen);

/**
 * @brief
 *  Decompresses the source buffer into the destination buffer.  
 *	sourceLen is the byte length of the source buffer. 
 * @param[out] u8*dest
 * @param[in/out] u32 *destLen
 * @param[in] const u8* source
 * @param[in] u32 sourceLen
 * @return MFSDK_UTIL_RET_OK / MFSDK_UTIL_RET_FAILED
 */
 
LIB_EXPORT s32 MfSdkUtilUncompress (u8*dest, u32 *destLen, const u8* source, u32 sourceLen);

/**
 * @brief save data to zip file
 * 
 * @param[in] const char *zip_filename zip file name 
 * @param[in] const char *file_name_in_zip  compress data file name
 * @param[in] const u8 *data compress data
 * @param[in] u32 data_len  compress data length
 * @return MFSDK_UTIL_RET_PARM_ERROR 
 * @return MFSDK_UTIL_RET_FAILED
 * @return MFSDK_UTIL_RET_OK
 */
LIB_EXPORT s32 MfSdkUtilSave2Zip(const char *zip_filename, const char *file_name_in_zip, const u8 *data, u32 data_len);

#endif /* __MFSDK_UTIL_H__ */

