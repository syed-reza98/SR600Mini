#ifndef __LIBAPI_UTIL_HEADER__
#define __LIBAPI_UTIL_HEADER__

/**
 * @file libapi_util.h
 * @author caijh(Eric)
 * @brief Tool related functions
 * @date 2023-05-23
 * @copyright Fujian MoreFun Electronic Technology Co., Ltd.
 */

#include "libapi_pub.h"

 //QR code parameters
typedef struct _QRParam
{
	int nVersion;		///< version number:1~40
	int nLevel;			///< Error correction level: 0-low, 1-in, 2-high, 3-maximum,
	int moudleWidth;	///< Module width (unit: pixel)
} Util_QR_INFO;

/**
 * @brief Get util module version
 *
 * @param[out] pszVer Module version 
 * @return	0, Success 
 * @return	Other, Failure
 */
LIB_EXPORT int Util_GetModuleVer(char *pszVer);

/**
 * @brief ASCII code to BCD code
 * 
 * @param[in] AscBuf ASCII code data to be converted
 * @param[out] BcdBuf Conversion output BCD code data
 * @param[in] AscLen Incoming ASCII code data length
 * @return	0, Success 
 * @return	Other, Failure
 * @details The left is BCD code, and the digit is insufficient to supplement'F'
 */
LIB_EXPORT int Util_Asc2Bcd(char *AscBuf, char *BcdBuf, int AscLen);

/**
 * @brief BCD code to ASCII code
 *
 * @param[in] BcdBuf BCD code data to be converted
 * @param[out] AscBuf Conversion output ASCII code data
 * @param[in] AscLen The length of ASCII code data, that is the double length of BCD code data
 * @return	0, Success 
 * @return	Other, Failure
 */
LIB_EXPORT int Util_Bcd2Asc(char *BcdBuf, char *AscBuf, int AscLen);


/**
 * @brief
 * 
 * @param[] const unsigned char* pszBcdBuf
 * @param[] int AscLen
 * @param[] char cAlignment 1 - left align , 0 - right align
 * @param[] unsigned char* pszAsciiBuf
 * @return UUTIL_SUCCESS
 * @return UUTIL_FAIL 
 */
LIB_EXPORT int Util_Hex2Asc(const unsigned char* pszBcdBuf, int AscLen, char cAlignment, unsigned char* pszAsciiBuf);


/**
 * @brief Int data transfer to BCD code
 *
 * @param[in] IntData Int data to be converted
 * @param[out] BcdBuf BCD data after conversion
 * @param[in] BcdLen Length of BCD code data after conversion
 * @return	0, Success 
 * @return	Other, Failure
 * @details The BCD code is on the right, and the number is not enough to add 0 to the left
 */
LIB_EXPORT int Util_Int2Bcd(uint IntData, char *BcdBuf, int BcdLen);

/**
 * @brief BCD code to int type
 *
 * @param[in] BcdBuf BCD data to be converted
 * @param[out] IntData Int data after conversion
 * @param[in] BcdLen BCD code data length
 * @return	0, Success 
 * @return	Other, Failure
 */
LIB_EXPORT int Util_Bcd2Int(char *BcdBuf, uint *IntData, int BcdLen);
/**
 * @brief Unicode data transfer to utf-8 code
 *
 * @param[in] codepoint Unicode data to be converted
 * @param[out] outstr utf-8 data after conversion
 * @return	The length of outstr
 */
LIB_EXPORT int Util_UnicodeToUtf8(unsigned short codepoint, char *outstr);

/**
 * @brief utf-8 code data transfer to Unicode
 *
 * @param[in] instr utf-8 data to be converted
 * @param[out] outstr Unicode data after conversion
 * @return	The length of outstr
 */
LIB_EXPORT int Util_Utf8ToUnicode(unsigned char *instr, unsigned char *outstr);

/**
 * @brief Calculates LRC and generates LRC parity bits (bitwise exclusive or)
 *
 * @param[in] Data Data to be calculated for LRC check bits
 * @param[in] DataLen Data length
 * @return  The LRC check value generated by calculation
 */
LIB_EXPORT byte Util_GenLrc(char *Data, int DataLen);

/**
 * @brief DES encryption and decryption to DES data encryption and decryption, or 3DES encryption and decryption
 *
 * @param[in]  bDesType DES encryption and decryption algorithm: 
				0 denotes DES encryption, 
				1 denotes DES decryption, 
				2 denotes 3DES encryption, 
				3 denotes 3DES decryption.
 * @param[in] Key Used for encryption and decryption of transmission keys, must be 8 times
 * @param[in] InData Encrypted data to be decrypted must be 8 bytes
 * @param[out] OutData The key after encryption and decryption must be 8 bytes
 * @return	0, Success 
 * @return	Other, Failure
 */
LIB_EXPORT int Util_Des(byte bDesType, char *Key, char *InData, char *OutData);

/**
 * @brief DES encryption and decryption to DES data encryption and decryption, or 3DES encryption and decryption
 *
 * @param[in]  bDesType DES encryption and decryption algorithm:
				0 denotes DES encryption, 
				1 denotes DES decryption, 
				2 denotes 3DES encryption(16 bytes key), 
				3 denotes 3DES decryption(16 bytes key),
				4 denotes 3DES encryption(24 bytes key), 
				5 denotes 3DES decryption(24 bytes key).
 * @param[in] bDesMode 0 ECB 1 CBC
 * @param[in] Key Used for encryption and decryption of transmission keys, must be 8 times
 * @param[in] InData Input data to be encrypted or decrypted must be 8 times bytes
 * @param[in] DataLen The length of input data
 * @param[out] OutData The key after encryption and decryption must be 8 bytes
 * @return	0, Success 
 * @return	Other, Failure
 */
LIB_EXPORT int Util_Des_Ex(byte bDesType, byte bDesMode, char *Key, char *InData, int DataLen, char *OutData);
/**
 * @brief Waiting button (Util_WaitKey) waits for the button within the set time, while the Nothing button waits for the timeout.
 *
 * @param[in] TimeOut Waiting timeout time (seconds), 0 means blocking
 * @return  >=0, key value
 * @return	Other, failure
 */
LIB_EXPORT int Util_WaitKey(int TimeOut);

/**
 * @brief Buzzing success indicates buzzing when successful, non blocking
 *
 * @param[in] num Buzz times
 */
LIB_EXPORT void Util_Beep(int num);

/**
 * @brief Set the buzzer ringing time
 * 
 * @param[in] nMillisecond ringing time(Unit millisecond)
 */
LIB_EXPORT void Util_BuzzerSound(int nMillisecond);

/**
 * @brief Generating random numbers
 *
 * @param[out] psRandom 8 byte Binary random number
 * @return	0, Success
 * @return	Other, Failure
 * @details Priority of true random numbers
 */
LIB_EXPORT int Util_Rand(byte *psRandom);

/**
 * @brief Generating random numbers
 *
 * @param[in] len random number len
 * @param[out] pBuf random number
 * @return	0, Success
 * @return	Other, Failure
 * @details Priority of true random numbers
 */
LIB_EXPORT int Util_Get_Rand(int len, unsigned char* pBuf);
/**
 * @brief Util_SHA1
 *
 * @param[in] psSrc Source buffer
 * @param[in] nSrcLen Source length
 * @param[out] psDst Result of SHA1
 * @return	0, Success 
 * @return	Other, Failure
 */
LIB_EXPORT int Util_SHA1(const byte* psSrc, uint nSrcLen, byte* psDst);

/**
 * @brief Voice Play
 *
 * @param[in] msg Audio file
 * @details Voice playback is non blocking
 */
LIB_EXPORT void Play_Voice(char *msg);

/**
 * @brief QR code generation
 *
 * @param[in] chData QR code data
 * @param[in] iLen Data length
 * @param[in] qrparam QR code parameters
 * @param[out] bitmap Generated two-dimensional code dot matrix data
 * @return	>0, Successfully generated QR code width
 * @return	Other, Failure
 */
LIB_EXPORT int Util_GeneCodePic(char * chData, int iLen, Util_QR_INFO *qrparam , char * bitmap);

/**
 * @brief LED light control
 *
 * @param[in] num LED light number(0 red, 1 blue, 2 yellow, 3 green)
 * @param[in] type LED light switch(0 close, 1 open)
 */
LIB_EXPORT void Util_Led(int num, int type);

/**
 * @brief Request memory
 *
 * @param[in] size Memory size
 * @return	Application Memory Pointer
 */
LIB_EXPORT void * Util_Malloc(int size);

/**
 * @brief Release memory
 *
 * @param[in] p A pointer to release memory
 */
LIB_EXPORT void Util_Free( void * p);

/**
 * @brief Get scan data
 *
 * @param[in] code scan data
 * @param[in] size scan size
 * @return	0,fail
 * @return	1,success
 */
LIB_EXPORT int Util_qrdecode_decode(char* code, int size);

/**
 * @brief Get scan image
 *
 * @return	scan image
 * @details (MF960:480*640)
 */
LIB_EXPORT char* Util_scaner_get_img();

/**
 * @brief close scaner
 *
 * @return	0,success
 * @return	Other,fail
 */
LIB_EXPORT int Util_scaner_close();

/**
 * @brief open scaner
 *
 * @return	0,success
 * @return	Other,fail
 */
LIB_EXPORT int Util_scaner_open();

/**
 * @brief
 * 
 * @param[in] const char *amt
 * @return txt to long long eg. "10000" to 10000
 */
LIB_EXPORT long long Util_str2longlong(const char *amt);

/**
 * @brief
 * 
 * @param[in] char *utfstr
 * @param[in] int utfchars
 * @param[out] unsigned char *astr
 * @param[in] int buffsize
 * @return 
 */
LIB_EXPORT int Util_Utf8str2Astr( char *utfstr, int utfchars, unsigned char *astr, int buffsize);

/**
 * @brief Character Copy
 *
 * @param[out] dst Target data string
 * @param[in] src Source data string
 * @param[in] len Source data length
 * @return  The length of the copied string
 */
LIB_EXPORT int Util_StrCopy(char* dst, cchar* src, int len);
/**
 * @brief Set whether to turn on the key tone
 *
 * @param[in] nOpen 1 open; 0 close
 * @return	Nothing
 */
LIB_EXPORT void Util_SwitchKeySound(int nOpen);

/**
 * @brief Get whether to turn on the key tone
 *
 * @return	1, open
 * @return	0, close
 */
LIB_EXPORT int Util_GetKeySound();


LIB_EXPORT int Util_InputMethod(int disp_line, char* msgPrompt, int input_line, char* str, int min, int max, byte disp_pattern, int timeout);
LIB_EXPORT int Util_InputTextEx(int disp_line, char* msgPrompt, int input_line, char* str, int min, int max, int disp_pattern, byte disp_mode, int timeout, char* title);
LIB_EXPORT int Util_InputText(int disp_line, char* msgPrompt, int input_line, char* buff, int min, int max, int disp_pattern, byte disp_mode, int timeout);
LIB_EXPORT int Util_InputText2(int disp_line, char* msgPrompt, int input_line, char* buff, int min, int max, int disp_pattern, byte disp_mode, int timeout, void(*extra_paint)(void* extra), const void* extra);
LIB_EXPORT int Util_InputTextEx2(int disp_line, char* msgPrompt, int input_line, char* buff, int min, int max, int input_pattern, int disp_pattern, byte disp_mode, int timeout, char* title);
LIB_EXPORT int Util_InputAmount(int disp_line, char* msgPrompt, int input_line, char* amount, byte disp_pattern, int timeout);
LIB_EXPORT int Util_InputIp(int disp_line, char* msgPrompt, int input_line, char* ip, byte disp_pattern, int timeout);
#endif /*__LIBAPI_UTIL_HEADER__*/
